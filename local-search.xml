<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>正规方程的推导</title>
    <link href="/2021/07/13/normalEqu/"/>
    <url>/2021/07/13/normalEqu/</url>
    
    <content type="html"><![CDATA[<p>本篇主要介绍正规方程公式的推导，关于正规方程详情，可参考<a href="https://blog.zewan.cc/2021/07/12/ml-regression/#%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B-Normal-Equation">线性回归 - Zewan Blog</a>。</p><h2 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="线性代数基础"></a>线性代数基础</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>设 $A$ 为 $m\times p$ 的矩阵，$B$ 为 $p\times n$ 的矩阵，则称 $m\times n$ 的矩阵 $C$ 为 $A$ 与 $B$ 的乘积，记作 $C=AB$，其中矩阵 $C$ 的第 $i$ 行第 $j$ 列元素为：</p><p>$$<br>(AB)_{ij} =<br>\sum^{p}_{k=1}<br>a_{ik}b_{kj}=a_{i1}b_{1j}+a_{i2}b_{2j}+\cdots+a_{ip}b_{pj}<br>$$</p><p>例如：</p><p>$$<br>A =<br>\left[<br>\begin{matrix}<br>1 &amp; 2 &amp; 3  \\<br>4 &amp; 5 &amp; 6  \\<br>\end{matrix}<br>\right];<br>B =<br>\left[<br>\begin{matrix}<br>7 &amp; 8   \\<br>9 &amp; 10  \\<br>11 &amp; 12<br>\end{matrix}<br>\right]<br>$$</p><p>则 $A$ 与 $B$ 的乘积为：</p><p>$$<br>C=AB=<br>\left[<br>\begin{matrix}<br>1\times 7+2\times 9+3\times 11 &amp; 1\times 8+2\times 10+3\times 12   \\<br>4\times 7+5\times 9+6\times 11 &amp; 4\times 8+5\times 10+6\times 12<br>\end{matrix}<br>\right]<br>$$</p><h3 id="矩阵的可逆性"><a href="#矩阵的可逆性" class="headerlink" title="矩阵的可逆性"></a>矩阵的可逆性</h3><p>给定一个 $n$ 阶<strong>方阵</strong> $A$，若存在一个 $n$ 阶方阵 $B$ 使得 $AB=BA=I$，其中 $I$ 为单位矩阵，则称 $A$ 可逆，且 $B$ 为 $A$ 的逆矩阵，记作 $A^{-1}$。</p><p>若方阵 $A$ 的逆矩阵存在，则称 $A$ 可逆，为非奇异矩阵，其列向量必线性无关。</p><blockquote><p>奇异矩阵即为不可逆矩阵</p></blockquote><div class="note note-warning">            <p>注意可逆性是对于方阵而言，非方阵矩阵（行列数不同）必不可逆</p>          </div><h3 id="矩阵求导法则"><a href="#矩阵求导法则" class="headerlink" title="矩阵求导法则"></a>矩阵求导法则</h3><p>先列两个直接用到的恒等式。</p><p>$$<br>\begin{aligned}<br>\frac{\mathrm{d}AB}{\mathrm{d}B} &amp;= A^{T} \\<br>\frac{\mathrm{d}X^{T}AX}{\mathrm{d}X} &amp;= 2AX<br>\end{aligned}<br>$$</p><h2 id="正规方程简述"><a href="#正规方程简述" class="headerlink" title="正规方程简述"></a>正规方程简述</h2><p>训练集中有 $m$ 个样本，每个样本有 $n$ 个线性无关的特征和一个标签纸（输出值）$y$。建立多变量线性回归模型和代价函数：($x_{0}$ 为 1)</p><ul><li><p>回归模型：$h_{\theta}(x)=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}=\theta^{T}X$</p></li><li><p>代价函数：$J(\theta_{0},\theta_{1},…,\theta_{n})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2$</p></li></ul><p>现使用特征 $\frac{\partial J(\theta)}{\partial\theta}=0$，推导出参数方程：</p><p>$$<br>\theta=(X^{T}X)^{-1}X^{T}y<br>$$</p><p>其中，$X$ 表示特征矩阵（含$x_{0}=1$），$T$ 表示矩阵转置，$y$ 为训练集的结果，是一个向量。即：</p><p>$$<br>\theta =<br>\left[<br>\begin{matrix}<br>\theta_{0} \\<br>\theta_{1} \\<br>. \\<br>. \\<br>\theta_{n}<br>\end{matrix}<br>\right];<br>X =<br>\left[<br>\begin{matrix}<br>x_{0}^{(1)} &amp; … &amp; x_{n}^{(1)} \\<br>. &amp; . &amp; . \\<br>x_{0}^{m} &amp; … &amp; x_{n}^{m}<br>\end{matrix}<br>\right];<br>y =<br>\left[<br>\begin{matrix}<br>y_{1} \\<br>y_{2} \\<br>. \\<br>. \\<br>y_{m}<br>\end{matrix}<br>\right]<br>$$</p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>将代价函数 $J(\theta)$ 转为矩阵表达形式，有</p><p>$$<br>J(\theta) = \frac{1}{2}(X\theta-y)^{2}<br>$$</p><blockquote><p>上式 $X\theta-y$ 为 $(m,1)$ 向量，平方仅代表各元素做平方运算</p></blockquote><p>对 $J(\theta)$ 进行如下变换：</p><p>$$<br>\begin{aligned}<br>J(\theta) &amp;=  \frac{1}{2}(X\theta-y)^{T}(X\theta-y)\\<br>&amp;= \frac{1}{2}(\theta^{T}X^{T}-y^{T})(X\theta-y)\\<br>&amp;= \frac{1}{2}(\theta^{T}X^{T}X\theta-\theta^{T}X^{T}y-y^{T}X\theta+y^{T}y)<br>\end{aligned}<br>$$</p><p>接下来使用矩阵的求导法则 $\frac{\mathrm{d}AB}{\mathrm{d}B}=A^{T},\frac{\mathrm{d}X^{T}AX}{\mathrm{d}X}=2AX$，对 $J(\theta)$ 偏导，得：</p><p>$$<br>\begin{aligned}<br>\frac{\partial J(\theta)}{\partial \theta}<br>&amp;= \frac{1}{2}(2X^{T}X\theta-X^{T}y-(y^{T}X)^{T}+0)\\<br>&amp;= \frac{1}{2}(2X^{T}X\theta-X^{T}y-X^{T}y+0)\\<br>&amp;= X^{T}X\theta-X^{T}y<br>\end{aligned}<br>$$</p><p>令 $\frac{\partial J(\theta)}{\partial \theta}=0$，得</p><p>$$<br>\theta = (X^{T}X)^{-1}X^{T}y<br>$$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.coursera.org/learn/machine-learning">[1] 吴恩达 Andrew Ng 机器学习课程</a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes">[2] 黄海广博士的机器学习笔记</a></p><p><a href="https://zhuanlan.zhihu.com/p/60719445">[3] 详解正规方程 (Normal Equation) - 知乎</a></p><p><a href="https://fei-wang.github.io/matrix.html">[4] 矩阵求导 - 蒙奇 D 路飞</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>ML</tag>
      
      <tag>推导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归</title>
    <link href="/2021/07/12/ml-regression/"/>
    <url>/2021/07/12/ml-regression/</url>
    
    <content type="html"><![CDATA[<h2 id="单变量线性回归-Linear-Regression-with-One-Variable"><a href="#单变量线性回归-Linear-Regression-with-One-Variable" class="headerlink" title="单变量线性回归 (Linear Regression with One Variable)"></a>单变量线性回归 (Linear Regression with One Variable)</h2><p>我们使用上一章房价的例子，介绍模型表示、代价函数、梯度下降的一些基本概念。</p><h3 id="模型表示-Model-Representation"><a href="#模型表示-Model-Representation" class="headerlink" title="模型表示 (Model Representation)"></a>模型表示 (Model Representation)</h3><p>首先，对于房价这个监督学习的例子，我们有一个数据集，称为<strong>训练集</strong>。假设数据如下：</p><table><thead><tr><th align="center">Size(x)</th><th align="center">Price in 1w’s(y)</th></tr></thead><tbody><tr><td align="center">101</td><td align="center">98</td></tr><tr><td align="center">134</td><td align="center">156</td></tr><tr><td align="center">201</td><td align="center">237</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>用以下符号来描述这个回归问题：</p><ul><li>$m$ 代表训练集中实例的数量</li><li>$x$ 代表特征/输入变量</li><li>$y$ 代表目标变量/输出变量</li><li>$(x,y)$ 代表训练集中的实例</li><li>$(x^{(i)},y^{(i)})$ 代表第$i$个观察实例</li><li>$h$ 代表学习算法的解决方案或函数，也称为<strong>假设 (hypothesis)</strong></li></ul><p><img src="/img/articles/21-7-11/ml-flow.jpg" alt="监督学习算法的工作流程"></p><p>上图展示了监督学习算法的工作方式。可以看到，训练集里有房屋尺寸及其对应的价格，我们将它 feed 给学习算法，然后输出一个函数 $h$。这时我们输入房屋大小 $x$，$h$ 则会输出对应的房屋价格预测值 $y$。因此 $h$ 是一个从 $x$ 到 $y$ 的函数映射。</p><p>如何表达 $h$ 呢？我们可以用简单的线性回归，将其表示为 $h_{\theta}(x)=\theta_{0}+\theta_{1}x$，因为只含有一个特征变量，因此叫做<strong>单变量线性回归问题</strong>。</p><h3 id="代价函数-Cost-Function"><a href="#代价函数-Cost-Function" class="headerlink" title="代价函数 (Cost Function)"></a>代价函数 (Cost Function)</h3><p>在上一部分我们为模型引入了<strong>参数</strong> $\theta_{0}$ 和 $\theta_{1}$，在房价问题的例子中表示直线在 $y$ 轴上的截距和直线的斜率。接下来我们要做的便是为模型选择合适的参数 (parameters)。事实上这就是 feed 的过程。</p><p>选择的参数决定了我们得到的直线相对于我们训练集的准确程度，我们称模型的预测值与实际值的差距为建模误差 (modeling error)。此时目标是选择出使得建模误差的平方和最小的模型参数。</p><p>定义<strong>代价函数</strong>表示建模误差：</p><p>$$<br>J(\theta_{0},\theta_{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2<br>$$</p><p>我们知道，对特定的 $\theta_{0}$ 和 $\theta_{1}$，我们能得到对应的代价值 $J$。因此 $J$ 是关于 $\theta_{0}$ 和 $\theta_{1}$ 的函数。将其绘制成一个等高线图，三个坐标分别为 $\theta_{0}$、$\theta_{1}$ 和 $J(\theta_{0},\theta_{1})$：</p><p><img src="/img/articles/21-7-11/lineheight.png" alt="图源于Coursera"></p><p>可以直观地看到，三维空间中存在一个使 $J(\theta_{0},\theta_{1})$ 最小的点。</p><p>在这里罗列一下前面的概念：</p><table><thead><tr><th align="center">Concept</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">Hypothesis</td><td align="center">$h_{\theta}(x) = \theta_{0} + \theta_{1} x$</td></tr><tr><td align="center">Parameters</td><td align="center">$\theta_{0},\theta_{1}$</td></tr><tr><td align="center">Cost Function</td><td align="center">$J(\theta_{0},\theta_{1})=\frac{1}{2m}\Sigma_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2$</td></tr><tr><td align="center">Goal</td><td align="center">minimize $J(\theta_{0},\theta_{1})$</td></tr></tbody></table><h3 id="参数求解-Parameter-Learning"><a href="#参数求解-Parameter-Learning" class="headerlink" title="参数求解 (Parameter Learning)"></a>参数求解 (Parameter Learning)</h3><p><strong>梯度下降</strong> (Gradient Descent) 是一个求函数最小值的算法，下面将使用该算法求出代价函数 $J(\theta_{0},\theta_{1})$ 的最小值。</p><p>梯度下降：开始时随机选择一个参数组合 $(\theta_{0}, \theta_{1},…,\theta_{n})$，计算代价函数值，接下来寻找下一个能使代价函数值下降最多的参数组合，持续这么做直到到达一个局部最优解 (local optimal solution)。因此我们没有遍历所有参数组合（也不可能遍历），因此不确定得到的解是否为全局最优。</p><p><img src="/img/articles/21-7-11/Gradient.jpg" alt="图源于Coursera"></p><p>梯度下降的思想比较好理解。想象你站立在山的某个点，然后旋转 360 度，看看往哪个方向能下山，然后迈出一定距离的步伐。迈出一步后，重新环顾四周，持续上面的过程，直到到达某个点，发现四周都是上山的方向。</p><p><strong>批量梯度下降</strong> (batch gradient descent) 算法公式为：</p><p>$$<br>\theta_{j}:=\theta_{j}-\alpha\frac{\partial}{\partial\theta_{j}}J(\theta_{0},\theta_{1}), j=0或1<br>$$</p><p>其中 $\alpha$ 是<strong>学习率</strong> (learning rate)，决定每一次迈出的步子有多大。当 $\alpha$ 太小或太大时：</p><ul><li>$\alpha$ 太小，即学习速率低，达到局部最优的速度会很慢；</li><li>$\alpha$ 太大，即学习速率过快，迈的步子太大，可能会导致多次迭代都越过了局部最优点。</li></ul><p>在批量梯度下降中，我们每次都<strong>同时</strong>让所有参数减去学习速率乘代价函数的偏导。这里的同时，表示先根据当前点计算出式子右边的值（参数的新值），再同时更新参数。</p><p>在计算过程中，我们会发现，每次迭代（计算代价函数值）都会用到所有训练样本，因此该算法称为<strong>批量梯度下降</strong>。当然也存在其它类型的梯度下降法，不考虑计算整个训练集，而是每次只关注训练集的小子集。</p><h2 id="多变量线性回归-Linear-Regression-with-Multiple-Variables"><a href="#多变量线性回归-Linear-Regression-with-Multiple-Variables" class="headerlink" title="多变量线性回归 (Linear Regression with Multiple Variables)"></a>多变量线性回归 (Linear Regression with Multiple Variables)</h2><p>继续延续上面房价模型的例子，不同的是，房价往往与多个变量有关，比如大小、卧室数量、楼层数、房屋年龄等有关，因此我们引入多变量回归问题。</p><h3 id="多维特征-Multiple-Features"><a href="#多维特征-Multiple-Features" class="headerlink" title="多维特征 (Multiple Features)"></a>多维特征 (Multiple Features)</h3><p>建立模型，我们首先需要将其变量进行抽象表示。假设我们有这样的数据：</p><table><thead><tr><th align="center">Size (meter2)</th><th align="center">Number of bedrooms</th><th align="center">Number of floors</th><th align="center">Age of home (years)</th><th align="center">Price (1w)</th></tr></thead><tbody><tr><td align="center">2104</td><td align="center">5</td><td align="center">1</td><td align="center">45</td><td align="center">460</td></tr><tr><td align="center">1416</td><td align="center">3</td><td align="center">2</td><td align="center">40</td><td align="center">232</td></tr><tr><td align="center">1534</td><td align="center">3</td><td align="center">2</td><td align="center">30</td><td align="center">315</td></tr><tr><td align="center">852</td><td align="center">2</td><td align="center">1</td><td align="center">36</td><td align="center">178</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>同样用符号表示：</p><ul><li>$m$ 代表训练实例的数量</li><li>$n$ 代表特征的数量</li><li>$x^{(i)}$ 代表第 $i$ 个训练实例</li><li>$x^{(i)}_{j}$ 表示第 $i$ 个训练实例的第 $j$ 个特征</li><li>$X$ 代表特征矩阵，由 $x_{j}^{(i)}$ 组成，第 $i$ 行第 $j$ 列的元素为 $x^{(i)}_{j}$ </li></ul><p>我们可以将假设定义为多变量线性函数：</p><p>$$<br>h_{\theta}(x)=\theta_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}<br>$$</p><p>为简化公式，引入 $x_{0}=1$，则公式转化为：</p><p>$$<br>h_{\theta}(x)=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}<br>$$</p><p>即</p><p>$$<br>h_{\theta}(x)=<br>\left[<br>\begin{matrix}<br>\theta_{0} &amp; \theta_{1} &amp; … &amp; \theta_{n}<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x_{0} \\<br>x_{1} \\<br>. \\<br>. \\<br>x_{n}<br>\end{matrix}<br>\right]<br>=<br>\theta^{T}x<br>$$</p><blockquote><p>上标 $T$ 代表矩阵转置</p></blockquote><h3 id="多变量梯度下降"><a href="#多变量梯度下降" class="headerlink" title="多变量梯度下降"></a>多变量梯度下降</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>同样的，我们为该问题构建一个代价函数，即所有建模误差的平方和：</p><p>$$<br>J(\theta_{0},\theta_{1},…,\theta_{n})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2<br>$$</p><p>其中，$h_{\theta}(x)=\theta^{T}x=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$</p><p>此处给出简单的 <strong>Python</strong> 代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cost</span>(<span class="hljs-params">X, y, theta</span>):</span><br>    inner = np.power(((X * theta.T) - y), <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">sum</span>(inner) / (<span class="hljs-number">2</span> * <span class="hljs-built_in">len</span>(X))<br></code></pre></td></tr></table></figure><p>目标同样是找出使得代价函数最小的一系列参数。多变量线性回归的<strong>批量梯度下降算法</strong>为：</p><p>$$<br>Repeat:<br>\theta_{j}:=\theta_{j}-\alpha\frac{\partial}{\partial\theta_{j}}J(\theta_{0},\theta_{1},…,\theta_{n})<br>$$</p><p>代入函数求导，得到：</p><p>$$<br>\theta_{j}:=\theta_{j}-\alpha\frac{1}{m}\sum_{i=1}^{m}((h_{\theta}(x^{(i)})-y^{(i)})\cdot x_{j}^{i})<br>$$</p><p>一开始随机选择一系列参数值，计算预测结果，再由上式计算得到所有参数的新值，同时更新，如此循环直至收敛。</p><h4 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h4><p>继续考虑一下数据的问题。假设房价问题有两种特征数据，房屋尺寸和房间数量，尺寸的值为 0-2000 平方米，而房间数量值为 0-10。</p><p>可以发现，这两个参数的范围相差巨大，绘制代价函数时，图像会显得很扁，梯度下降算法需要非常多次迭代才能收敛。</p><p>解决的方法是将所有特征的尺度都尽量缩放到 -1 到 1 之间，保证特征在相似的范围内。比如：</p><p>$$<br>x_1 = \frac{size}{2000},x_2=\frac{nums}{5}<br>$$</p><p>当然，更常用和简单的方法是令：$x_{i}=\frac{x_{i}-\mu_{i}}{s_{i}}$，其中 $\mu_{i}$ 是第 $i$ 个特征的平均值，$s_{i}$ 是第 $i$ 个特征的方差。</p><h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p>梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们可以绘制图标来观测算法在何时趋于收敛。如下图，纵轴为代价函数值，横轴为迭代次数：</p><p><img src="/img/articles/21-7-11/iterations.jpg"></p><p>使用梯度下降算法，该图像应整体呈下降趋势，最后趋于收敛。</p><p>关于学习率 $\alpha$ 的选择，如果 $\alpha$ 过小，则迭代次数非常高，如果 $\alpha$ 过大，每次迭代可能不会减小代价函数值，可能会越过局部最小值导致无法收敛。</p><p>通常可以考虑尝试这些学习率：</p><p>$$<br>\alpha = 0.01,0.03,0.1,0.3,1,3,10<br>$$</p><h4 id="多项式回归-Polynomial-Regression"><a href="#多项式回归-Polynomial-Regression" class="headerlink" title="多项式回归 (Polynomial Regression)"></a>多项式回归 (Polynomial Regression)</h4><p>上面所使用的线性回归，不一定适用于所有数据，有时我们需要曲线来适应拟合数据。比如二次方模型：$h_{\theta}(x)=\theta_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}^{2}$ 或三次方模型等等。</p><p><img src="/img/articles/21-7-11/polynomial.jpg" alt="图源于Coursera"></p><p>通常我们需要先观察数据，再决定模型。如果采用多次项，可以令：$x_{2}=x_{2}^{2},x_3=x_{3}^{3}$，从而将模型转化为线性回归模型。</p><h3 id="正规方程-Normal-Equation"><a href="#正规方程-Normal-Equation" class="headerlink" title="正规方程 (Normal Equation)"></a>正规方程 (Normal Equation)</h3><p>到目前为止，都在使用梯度下降算法来求解参数，但对于某些线性回归问题，<strong>正规方程</strong>方法是更好的解法。</p><div class="note note-info">            <p>最小二乘法可以将误差方程转化为有确定解的代数方程组（方程式数目等于未知数的个数），从而可求解出这些位置参数。这个有确定解的代数方程组称为最小二乘法估计的<strong>正规方程（或法方程）</strong>。</p>          </div><p>看不懂上面的阐述没关系，我们依然拿房价的例子来理解一下。</p><p>首先，上述定义中的误差方程，即指前面所建立的代价函数。它所说的最小二乘法，正是我们用以建模的思想。这两个条件都满足的前提下，我们需要思考如何将代价函数转化为所谓的有确定解的方程组。</p><p><img src="/img/articles/21-7-11/partial.jpg"></p><p>这里运用了数学中极值点的思想。我们想找到代价函数最小的解，利用 $\frac{\partial}{\partial\theta_{j}}J(\theta_{j})=0$。共有 $n+1$ 个未知数 $\theta_{0},\theta_{1},..,\theta_{n}$，对每个未知数求偏导，得到 $n+1$ 个方程，即得到了有确定解的方程组。</p><p>$$<br>\frac{\partial}{\partial\theta_{j}}J(\theta_{j})=0<br>$$</p><p>利用上式，结合 $J(\theta)$ 的定义，我们得到非常重要且常用的公式：</p><blockquote><p>推导过程见<a href="https://blog.zewan.cc/2021/07/13/normalEqu/">正规方程的推导 - Zewan Blog</a></p></blockquote><p>$$<br>\theta=(X^{T}X)^{-1}X^{T}y<br>$$</p><p>其中，$X$ 表示特征矩阵（含$x_{0}=1$），$T$ 表示矩阵转置，$y$ 为训练集的结果，是一个向量。</p><p>使用上述公式，即可求解参数。Python 代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normalEqn</span>(<span class="hljs-params">X, y</span>):</span><br>    <span class="hljs-keyword">return</span> np.linalg.inv(X.T.dot(X)).dot(X.T).dot(y) <span class="hljs-comment"># np.linalg.inv 求逆，X.T 转置，.dot(X) 矩阵乘法，可 @ 代替</span><br></code></pre></td></tr></table></figure><p>当然，对于不可逆矩阵，通常是因为特征之间不独立，如同时包含以英尺为单位的特征和以米为单位的特征，或特征数量大于训练集数量，或存在<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3/6416511">线性相关</a>的特征，此时正规方程方法不可用。</p><p>梯度下降与正规方程的比较：</p><table><thead><tr><th>Item</th><th>梯度下降</th><th>正规方程</th></tr></thead><tbody><tr><td>是否需要选择学习率 $\alpha$</td><td>需要</td><td>不需要</td></tr><tr><td>计算过程</td><td>多次迭代</td><td>一次运算得出</td></tr><tr><td>特征数量 $n$</td><td>当特征数量 $n$ 大时也较适用</td><td>计算矩阵逆时间复杂度为 $O(n^{3})$，当 $n&lt;10000$ 时可以接受</td></tr><tr><td>适用性</td><td>适用于各种类型的模型</td><td>仅适用于线性模型</td></tr></tbody></table><p>关于两种方法的选择，当特征变量的数目不大，小于一万时，选择正规方程法，其它情况下还是选用梯度下降法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述是机器学习中线性回归问题的阐述。可以看到，针对房价这类问题，流程如下：</p><ol><li>根据数据特征建立模型（本文建立的是线性模型）</li><li>定义代价函数表示建模误差</li><li>使用求函数最小值的算法求解参数<ol><li>正规方程：当特征变量较少时选用</li><li>梯度下降：当特征变量多，或为非线性模型时采用，需选择合适的学习率</li></ol></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.coursera.org/learn/machine-learning">[1] 吴恩达 Andrew Ng 机器学习课程</a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes">[2] 黄海广博士的机器学习笔记</a></p><p><a href="https://baike.baidu.com/item/%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B/10001812">[3] 正规方程 - 百度百科</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习的基础分类与概念</title>
    <link href="/2021/07/10/ml-welcome/"/>
    <url>/2021/07/10/ml-welcome/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用深度学习框架完成了一个项目，感觉对机器学习的基础掌握得零零碎碎，趁暑假冲一波。</p></blockquote><p>本篇文章是机器学习系列的第一篇博客，讲述机器学习是什么、监督学习与无监督学习，并以单变量线性回归为例，介绍模型、代价函数与参数学习（梯度下降）。</p><h2 id="机器学习是什么"><a href="#机器学习是什么" class="headerlink" title="机器学习是什么"></a>机器学习是什么</h2><p>我们每天都在不知不觉中使用了机器学习的应用，比如使用百度能搜索到你需要的内容，邮箱能自动将部分邮件扔进垃圾邮件中，手机程序能认出你的照片并将其归类，等等。</p><p>机器学习作为一门多领域交叉学科，涉及各个行业和基础科学，受到广泛应用。</p><p><img src="/img/articles/21-7-11/ml-apply.png"></p><p>与普通程序不同的是，它可以理解为<strong>让机器自己学习怎样解决问题</strong>。例如在图像识别问题上，简单地让计算机执行固有功能流程，并不能很好地识别图片，这时唯一方法是让计算机学习怎样识别。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>机器学习有两个定义：</p><div class="note note-info">            <p><strong>Maching Learning Definition</strong></p><ol><li>Arthor Samuel(1959): Field of study that gives computers the ability to learn without being explicitly programmed.</li><li>Tom Mitchell(1998): Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</li></ol>          </div><p>Arthor Samuel 提出，机器学习是使计算机能够在没有明确编程的情况下学习的研究领域。他编写了一个西洋棋程序，让程序自己跟自己下了上万盘棋，久而久之，程序明白了什么是好的布局，于是玩西洋棋的水平得到了很大的提升。</p><p>Tom Mitchell 认为，一个好的机器学习程序是，能从经验 E 中学习，解决任务 T，达到性能度量值 P，当且仅当，有了经验 E 后，经过 P 评判，程序在处理 T 时的性能有所提升。</p><p>以下棋为例，任务 T 就是下棋，经验 E 是程序上万次的自我练习后所获得的经验，而 P 即为棋局布局的好坏度量。程序在多次下棋中积累经验，经过布局好坏度量进行评判，从而提升玩西洋棋的水平。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>机器学习有以下几类：</p><ul><li>监督学习 (Supervised Learning)：我们教计算机如何去学习</li><li>无监督学习 (Unsupervised Learning)：计算机自己学习</li><li>其它：强化学习 (Reinforcement Learning)、推荐算法 (recommender systems)</li></ul><p>具体将在下面分别介绍。</p><h2 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习 (Supervised Learning)"></a>监督学习 (Supervised Learning)</h2><p>前面我们说到，监督学习是程序员教计算机如何去学习，该特点体现为，<strong>我们所提供训练的数据是明确正确答案的</strong>。大家应该都有所了解，机器学习常常由 code 和 data 组成，我们使用数据集去训练机器，从而实现功能。监督学习的特征正是 right answers given。</p><p>监督学习常见的问题有回归问题、分类问题，我将在分别举例介绍后归纳监督学习的特征。</p><h3 id="回归问题-Regression"><a href="#回归问题-Regression" class="headerlink" title="回归问题 (Regression)"></a>回归问题 (Regression)</h3><p>对数学有所认识的人应该都了解过线性回归，而事实上它正是回归问题的一种。</p><p>举个简单的例子，现在已收集了一些北京房价的数据，并将其画出坐标图，横轴表示房子的面积，纵轴表示房价。基于这组数据，假如你想在北京买套 250 平方米的房子，大致价格是多少。</p><p><img src="/img/articles/21-7-11/regression.png"></p><p>使用学习算法，我们可以用一条直线拟合这些数据，根据该直线可以推测出房子大概需要 280w。当然这不是唯一的算法，也不是最好的算法。我们还可以用二次曲线拟合，推测价格为 310 w。以上就是监督学习的回归问题的例子。</p><p>可以看到，监督学习指的是，我们给学习算法一个数据集，这个数据集由“正确答案”组成。在房价例子中，我们给出了一系列房子的数据，这些数据包含每个样本的正确价格（实际售价），即正确答案。</p><p>而回归一词研究的是<strong>数据的连续性</strong>。房价实际上是离散值，但研究一系列房价时，我们通常将其看成连续的数值，从而推断其间的值。</p><h3 id="分类问题-Classification"><a href="#分类问题-Classification" class="headerlink" title="分类问题 (Classification)"></a>分类问题 (Classification)</h3><p>同样举例来说明一下分类问题。假设想通过肿瘤大小来推断乳腺癌良性与否，现拥有病历上的数据，即部分肿瘤尺寸对应是否恶性的数据点。</p><p>将其绘制出坐标图。该数据集中，横轴表示肿瘤的大小，纵轴值为 1 和 0，分别表示恶性肿瘤和良性肿瘤。</p><p><img src="/img/articles/21-7-11/classification.jpg"></p><p>我们使用 0 或 1 这样的离散值表示数据的准确值，这类问题我们称之为分类问题 (Classification)。分类指的是，我们的<strong>输出值是离散的</strong>。当然，分类并不要求输出值仅两个值，可以是多个离散的值。</p><p>在一般的机器学习问题中，我们大多遇到的不止一种特征。继续使用乳腺癌的例子，恶性与否并不仅仅取决于肿瘤大小，还与患者年龄、肿块密度等特征有关。因此我们常需要使用更多特征，以保证推测结果正确。</p><p>在机器学习中，使用的是<strong>支持向量机</strong>的算法，能存储无限多个特征，让计算机处理它们。以后应该会更新到该内容。</p><h3 id="回味监督学习"><a href="#回味监督学习" class="headerlink" title="回味监督学习"></a>回味监督学习</h3><p>通过上面两个例子，我们可以知道，监督学习的基本思想是，<strong>数据集中的每个样本都有相应的“正确答案”。</strong>我们再根据这些样本作出预测。而回归问题与分类问题的区别，在于输出值（或预测值、样本值）是连续还是离散的。</p><blockquote><p>我更喜欢把上面输出值（或预测值、样本值）认为是<strong>可能值</strong>。</p></blockquote><h2 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习 (Unsupervised Learning)"></a>无监督学习 (Unsupervised Learning)</h2><p>上一部分内容我们知道，监督学习的数据集是有正确答案的，比如乳腺癌问题，每条数据都已标明是阴性或阳性，即良性或恶性肿瘤。</p><p>与监督学习相比，<strong>无监督学习的数据没有所谓对应的正确答案</strong>，我们并没有告诉机器，数据点是什么，数据点也没有任何标签。不妨再拿乳腺癌问题说说，对无监督学习而言，只需要输入一系列特征，不需要告知恶性与否。</p><p>针对数据集，无监督学习能判断出两个或多个不同的聚集簇，我们称之为<strong>聚类算法</strong>。</p><p>聚类算法的应用是十分广阔的。比如百度新闻能在非常多的网络新闻内容中挑出同类、同主题的新闻，组成有关联的新闻，尽管它可能不能给出它的类别信息。还比如市场营销，对客户的分析，算法能将顾客划分到不同的细分市场，方便有效地销售。</p><p>当然，聚类只是无监督学习中的一种，<strong>非聚类算法则允许我们在复杂的信息或环境中寻找框架结构</strong>。比如鸡尾酒会问题 (<a href="https://en.wikipedia.org/wiki/Cocktail_party_effect">cocktail party</a>)。</p><p><img src="/img/articles/21-7-11/cocktail.jpg" alt="图源于维基百科"></p><p>鸡尾酒会问题是语音识别方向的典型问题。当我们在一个鸡尾酒会谈话时，周边噪音很大，我们还是可以听到朋友说的内容，在在远处突然有人叫自己的名字，我们也会马上注意到。</p><p>我们可以简化这个问题。放两个麦克风在房间中，麦克风在两个地方，离说话人的距离不同。每个麦克风同时记录两人说话的声音，听起来像是两份录音被叠加到一起。无监督学习能区分出两个音频资源，抽取出各人说话的录音。</p><p><img src="/img/articles/21-7-11/microphone.png" alt="图源于Coursera"></p><p>不管是聚类还是非聚类问题，它们的数据集都是无标记的，属于无监督学习。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了机器学习是什么，列举了两个主流定义，对比说明了监督学习与无监督学习的区别，在于数据是否有“正确答案”。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.coursera.org/learn/machine-learning">[1] 吴恩达 Andrew Ng 机器学习课程</a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes">[2] 黄海广博士的机器学习笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署 Nginx + Django + Vue</title>
    <link href="/2021/06/24/deploy-django-vue/"/>
    <url>/2021/06/24/deploy-django-vue/</url>
    
    <content type="html"><![CDATA[<p>本篇记录我配置和部署服务器的每一步，主要包括服务器配置 Django 虚拟环境、uWSGI 和 Nginx 的使用以及报错的纠正。以 Linux 服务器为例，因此需要具备一定的 Linux 知识基础。</p><h2 id="服务器预设"><a href="#服务器预设" class="headerlink" title="服务器预设"></a>服务器预设</h2><h3 id="租服务器"><a href="#租服务器" class="headerlink" title="租服务器"></a>租服务器</h3><p>各大云平台，如腾讯云、阿里云、华为云等，都有学生优惠。我这里选择的是腾讯云，原因：控制台界面简洁优雅。</p><p>相关配置仅供参考：</p><p><img src="/img/articles/21-6-24/server.png" alt="服务器配置"></p><ul><li>镜像信息：CentOS 7.6 64bit</li><li>实例规格：CPU 1核，内存 2GB</li><li>磁盘：系统盘 40GB</li><li>流量包套餐：带宽 5Mbps，流量包 1000GB/月（免费）</li></ul><h3 id="SSH-远程连接"><a href="#SSH-远程连接" class="headerlink" title="SSH 远程连接"></a>SSH 远程连接</h3><p>配置 SSH 远程连接，方便本地操作服务器，而无需每次都登录云平台。</p><p>在控制台中点击登录，进入服务器终端。第一步需要初始化超级用户 root 的密码，进入 superuser 权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo passwd       <span class="hljs-comment"># 初始化密码</span><br>su                <span class="hljs-comment"># 切换到root超级用户</span><br></code></pre></td></tr></table></figure><p>修改配置文件，允许密码或密钥远程连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ssh/sshd_config      <span class="hljs-comment"># 编辑ssh设置文件</span><br></code></pre></td></tr></table></figure><p>在打开的文件中，修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">RSAAuthentication yes                       <span class="hljs-comment"># 开启rsa验证，需要添加</span><br>PubkeyAuthentication yes                    <span class="hljs-comment"># 开启公钥登录，一般被注释掉了，去掉前面的#就好</span><br>AuthorizedKeysFile .ssh/authorized_keys     <span class="hljs-comment"># 公钥保存位置，原来就有</span><br>PasswordAuthentication yes                  <span class="hljs-comment"># 开启使用密码登录</span><br></code></pre></td></tr></table></figure><p>保存退出，重启 SSH 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart        <span class="hljs-comment"># 重启ssh服务</span><br></code></pre></td></tr></table></figure><p>设置完毕后，即可在本地 powershell 或 git bash 连接服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@&lt;IP address&gt;       <span class="hljs-comment"># IP address 为你服务器的公网IP地址</span><br></code></pre></td></tr></table></figure><p>另外，VScode 的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote - SSH</a> 远程连接插件真香。</p><h3 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h3><p>配置公钥后，本地连接服务器，无需每次都输入密码。</p><p>首先，生成本地电脑的公钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa           <span class="hljs-comment"># 打开cmd或powershell输入</span><br></code></pre></td></tr></table></figure><p>默认回车即可，成功后在 <code>C:\Users\用户名\.ssh</code> 文件夹下会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code>，后者就是本地用户的密钥。打开该文件，复制内容。然后使用 ssh 命令登录远程服务器，在 root 用户根目录下创建 .ssh 文件夹并进入，再创建 authorized_keys 文件，将密钥粘贴进去，之后重启 ssh 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart        <span class="hljs-comment"># 重启ssh</span><br></code></pre></td></tr></table></figure><h3 id="更新系统软件包"><a href="#更新系统软件包" class="headerlink" title="更新系统软件包"></a>更新系统软件包</h3><p>服务器的预配置都比较古老，依次输入以下命令升级软件包或依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum update -y                               <span class="hljs-comment"># 更新系统软件包</span><br>yum -y groupinstall <span class="hljs-string">&quot;Development tools&quot;</span>     <span class="hljs-comment"># 安装软件管理包</span><br>yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel psmisc libffi-devel epel-release     <span class="hljs-comment"># 安装可能使用的依赖</span><br></code></pre></td></tr></table></figure><h2 id="配置-Django"><a href="#配置-Django" class="headerlink" title="配置 Django"></a>配置 Django</h2><h3 id="安装-python3-8-4"><a href="#安装-python3-8-4" class="headerlink" title="安装 python3.8.4"></a>安装 python3.8.4</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>                   <span class="hljs-comment"># 我一般喜欢把文件下载到该目录下</span><br>wget https://www.python.org/ftp/python/3.8.4/Python-3.8.4.tgz<br>tar -zxvf Python-3.8.4.tgz      <span class="hljs-comment"># 解压python包</span><br></code></pre></td></tr></table></figure><p>进入 Python 包路径，并编译安装到指定路径 /usr/local/python3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> Python-3.8.4<br>./configure --prefix=/usr/<span class="hljs-built_in">local</span>/python3<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>安装成功后，建立软链接，添加环境变量。因为服务器系统自带有 python、python2、python3，因此我命名为 python3.8，避免冲突。但我的服务器只有 pip3 没有 pip，所以我将 pip3.8 的软连接命名为 pip。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/python3.8 /usr/bin/python3.8<br>ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/pip3.8 /usr/bin/pip<br></code></pre></td></tr></table></figure><p>检测是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3.8 -V<br>pip -V<br></code></pre></td></tr></table></figure><h3 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h3><p>建议安装虚拟环境 virtualenv，当不同项目要求的 python 版本不同时，不会产生冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install virtualenv<br>pip install virtualenvwrapper       <span class="hljs-comment"># 管理虚拟环境</span><br></code></pre></td></tr></table></figure><p>下载成功后，创建存储虚拟环境的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir ~/.virtualenvs                <span class="hljs-comment"># 我一般存放在 /root/.virtualenvs，可自行修改</span><br></code></pre></td></tr></table></figure><p>查找 <code>virtualenvwrapper.sh</code> 文件位置，添加环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name virtualenvwrapper.sh<br></code></pre></td></tr></table></figure><p>编辑 <code>.bash_profile</code> 文件，在末尾添加这两句，其中 <code>source</code> 后的路径为前面查到的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> WORKON_HOME=<span class="hljs-variable">$HOME</span>/.virtualenvs<br><span class="hljs-built_in">source</span>  /usr/<span class="hljs-built_in">local</span>/python3/bin/virtualenvwrapper.sh<br></code></pre></td></tr></table></figure><p>保存修改后，更新配置信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile <br></code></pre></td></tr></table></figure><p>如果保存时报错，在 /etc/profile 中加入下面内容，再 <code>source</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.8<br><span class="hljs-built_in">export</span> VIRTUALENVWRAPPER_VIRTUALENV=/usr/<span class="hljs-built_in">local</span>/python3/bin/virtualenv<br></code></pre></td></tr></table></figure><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>通过 -p 指定使用的Python版本，创建成功后自动进入该虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkvirtualenv -p python3.8 django        <span class="hljs-comment"># django为虚拟环境名称</span><br></code></pre></td></tr></table></figure><p>如果你希望将当前虚拟环境安装的所有插件配置到新虚拟环境中，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip freeze &gt; requirements.txt           <span class="hljs-comment"># 导出依赖</span><br>pip install -r requirements.txt         <span class="hljs-comment"># 进入新虚拟环境后再执行</span><br></code></pre></td></tr></table></figure><p><strong>虚拟环境的其它常用命令</strong></p><ul><li>查看创建的全部虚拟环境：<code>workon</code></li><li>使用某一虚拟环境：<code>workon 虚拟环境名称</code></li><li>退出当前虚拟环境：<code>deactivate</code></li><li>删除虚拟环境：<code>rmvirtualenv 虚拟环境名称</code> 记得退出再删除</li></ul><h3 id="虚拟环境中安装-Django-和-uWSGI"><a href="#虚拟环境中安装-Django-和-uWSGI" class="headerlink" title="虚拟环境中安装 Django 和 uWSGI"></a>虚拟环境中安装 Django 和 uWSGI</h3><p>uWSGI 可以理解为服务器上持续运行 Django 的代理服务器，用于与 Django 后端进行数据传输等，后续配置需要使用。</p><p>进入前面创建的虚拟环境，安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install django==3.2         <span class="hljs-comment"># 可指定版本</span><br>pip install uwsgi<br></code></pre></td></tr></table></figure><blockquote><p>uWSGI 要安装两次，一次在虚拟环境中，另一次退出虚拟环境进行安装</p></blockquote><p>创建 uWSGI 的软链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/uwsgi /usr/bin/uwsgi<br></code></pre></td></tr></table></figure><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p>Nginx 是 Http 反向代理 web 服务器，同时也提供 IMAP/POP3/SMTP 服务，占用内存少，并发能力强。在这里我们只需要了解，Nginx 能帮我们在指定端口跑我们的项目就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install nginx<br></code></pre></td></tr></table></figure><p>安装成功后，相关的文件存储路径为</p><ul><li>安装成功后，默认的网站目录为 <code>/usr/share/nginx/html</code></li><li>默认的配置文件为 <code>/etc/nginx/nginx.conf</code></li><li>自定义配置文件目录为 <code>/etc/nginx/conf.d/</code></li></ul><p>在启动之前，还需确保服务器的相关端口已打开。http 对应 80 端口，https 对应 443 端口。一般在云平台租的服务器，可以在控制台中的防火墙处开启相应端口。我的设置可供参考。</p><p><img src="/img/articles/21-6-24/duankou.png" alt="服务器端口"></p><p>接下来启动 Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start nginx<br></code></pre></td></tr></table></figure><p>启动成功后，浏览器搜索服务器 IP 地址，就能访问到 Nginx 主页了。</p><p><img src="/img/articles/21-6-24/Nginx.jpg" alt="Nginx 默认主页"></p><h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><h3 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h3><p>Django 后端项目文件，直接上传至服务器即可。Vue 框架写的前端，需要使用 <code>npm run build</code> 命令进行打包，再将生成的 dist 目录上传。</p><p>这里推荐软件 <a href="https://filezilla-project.org/">FileZilla</a>，用于本地与服务器文件传输十分方便。</p><h3 id="配置-uWSGI"><a href="#配置-uWSGI" class="headerlink" title="配置 uWSGI"></a>配置 uWSGI</h3><p>新建文件 uwsgi.ini，我习惯放置于 Django 项目的根目录下，用于指定项目路径、最大进程数、运行端口等。我的配置参数可供参考。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><br><span class="hljs-attr">socket</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span><br><span class="hljs-attr">chdir</span> = /root/Ops/django<br><span class="hljs-attr">wsgi-file</span> = /root/Ops/django/django3/wsgi.py<br><span class="hljs-attr">master</span> = <span class="hljs-literal">true</span> <br><span class="hljs-attr">enable-threads</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">processes</span> = <span class="hljs-number">8</span><br><span class="hljs-attr">buffer-size</span> = <span class="hljs-number">65536</span><br><span class="hljs-attr">vacuum</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">daemonize</span> = /root/Ops/django/uwsgi.log<br><span class="hljs-attr">virtualenv</span> = /root/.virtualenvs/django<br><span class="hljs-attr">uwsgi_read_timeout</span> = <span class="hljs-number">600</span><br><span class="hljs-attr">threads</span> = <span class="hljs-number">4</span><br><span class="hljs-attr">chmod-socket</span> = <span class="hljs-number">664</span><br></code></pre></td></tr></table></figure><p>简要介绍该文件的配置信息：</p><ul><li><code>[uwsgi]</code>：必须有这个[uwsgi]，不然会报错</li><li><code>socket</code>：该端口为后端 Django 的运行端口，可自定义，但须与后面 Nginx 的配置一致</li><li><code>chdir</code>：django 项目路径</li><li><code>wsgi-file</code>：django 项目的 wsgi.py 文件路径</li><li><code>master</code>：开启主进程</li><li><code>processes</code>：最大进程数量</li><li><code>vacuum</code>：当服务器退出的时候自动删除 unix socket 文件和 pid 文件</li><li><code>daemonize</code>：输出日志，有报错时可查看</li><li><code>virtualenv</code>：项目虚拟环境路径</li></ul><p>切换当前路径到 uwsgi.ini 文件所在目录，启动 uWSGI。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uwsgi --ini uwsgi.ini<br></code></pre></td></tr></table></figure><p>使用 <code>ps</code> 命令查看进程，检测是否成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -aux | grep uwsgi<br></code></pre></td></tr></table></figure><p><img src="/img/articles/21-6-24/uwsgi.png" alt="uwsgi 进程查看"></p><h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><blockquote><p>此处先给出部署域名的样例，仅服务器 IP 以后再给出。</p></blockquote><p>首先，删除 <code>/etc/nginx/nginx.conf</code> 文件中 <code>server&#123;...&#125;</code> 部分的代码。当然，如果怕出错，也可先将原本的 nginx.conf 文件备份一下。</p><p>接下来，在 <code>/etc/nginx/conf.d</code> 文件夹中修改默认文件 <code>default.conf</code>（若不存在则新建一个），文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br>    listen 80;<br>    listen 443 ssl;<br>    server_name  zewan.top www.zewan.top;<br><br>    location / &#123;<br>        root /root/Ops/vue/dist;<br>        index index.html index.htm;<br>        try_files $uri $uri/ /index.html;<br>    &#125;<br><br>    location /api &#123;        <br>        include /etc/nginx/uwsgi_params;<br>        uwsgi_pass 127.0.0.1:8080;                                                               <br>    &#125;<br><br>    ssl_certificate /etc/nginx/ssl/zewan.top.crt;<br>    ssl_certificate_key /etc/nginx/ssl/zewan.top.key;<br>    ssl_session_timeout  5m;<br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;<br>    ssl_prefer_server_ciphers  on;<br><br>    error_page 497  https://$host$uri?$args;<br>&#125;<br></code></pre></td></tr></table></figure><p>简要说明文件内容的作用：</p><ul><li><code>listen</code> 后接端口，即设定访问的端口，此处同时开放 80 和 443</li><li><code>server_name</code> 为访问域名</li><li><code>location /</code> 后描述前端 dist 项目文件夹的存放地址，<strong>需根据自身情况修改</strong>，注意 dist 即为前端项目的根目录</li><li><code>location /api</code> 后为后端项目运行端口，注意 <code>uwsgi_pass</code> 后须与之前 uWSGI 的配置保持一致</li><li><code>ssl_certificate[_key]</code> 为 SSL 证书存储路径</li></ul><p><strong>重要提醒</strong></p><p>采用 <code>location /api</code> 与 uWSGI 连接，最终将后端运行在 <code>:443/api/</code>。需保证后端的路由都是 <code>api/*</code>，即 Django 项目的 <code>urls.py</code> 文件所有路由前需加 <code>api/</code>。</p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>检测 Nginx 配置是否有误，成功后重启 Nginx 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t                <span class="hljs-comment"># 测试</span><br>nginx -s reload         <span class="hljs-comment"># 重新加载</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>，若修改了后端 Django 内容或其它内容，须重启 uWSGI 和 Nginx 服务，否则不生效！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep uwsgi         <span class="hljs-comment"># 查看uWSGI进程</span><br>killall -9 uwsgi            <span class="hljs-comment"># 用kill方法把uwsgi进程杀死</span><br>uwsgi --ini uwsgi.ini       <span class="hljs-comment"># 重启uwsgi</span><br>nginx -s reload             <span class="hljs-comment"># nginx平滑重启</span><br></code></pre></td></tr></table></figure><p>另外，如果你的项目文件存放于 root 用户目录下，访问网站时可能出现 500 或 403 Forbidden 权限报错，此时需修改 <code>/etc/nginx/nginx.conf</code>，将文件首行的 <code>user nginx</code> 修改为 <code>user root</code>。</p><p>至此网站已部署完毕，欢迎访问<a href="https://zewan.top/">我的网站</a>。项目<a href="https://github.com/ZewanHuang/Online-Publish-Vue">网上出版系统</a>已开源，欢迎交流学习！</p>]]></content>
    
    
    <categories>
      
      <category>配置与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/16/hello-world/"/>
    <url>/2021/06/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>给博客换了个主题 Hexo Fluid，体验极佳，顺便简略记录一下部署过程和 Hexo 的一些基本用法。</p><span id="more"></span><h2 id="关于-Hexo"><a href="#关于-Hexo" class="headerlink" title="关于 Hexo"></a>关于 Hexo</h2><blockquote><p>引自官方文档</p></blockquote><p><a href="https://hexo.io/" target="_blank">Hexo</a> 是一个快速建议的博客框架，可使用 <a href="https://daringfireball.net/projects/markdown/" target="_blank">Markdown</a> 编辑页面。</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank">Fluid</a> 是本博客采用的主题，十分美观，建议入坑。</p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><h3 id="1-准备环境-node-和-git"><a href="#1-准备环境-node-和-git" class="headerlink" title="1. 准备环境 node 和 git"></a>1. 准备环境 node 和 git</h3><p>node 环境的配置可以参照：<a href="https://www.cnblogs.com/jianguo221/p/11487532.html" target="_blank">windows安装npm教程–nodejs</a></p><p>上面参考资料只需要看前半部分。Git 安装较简单，大概下载安装即成功。</p><h3 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成后，找个你想放置博客项目文件的地方，执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init MyBlog<br><span class="hljs-built_in">cd</span> MyBlog<br>npm install<br></code></pre></td></tr></table></figure><p>新建完成后，文件夹目录与功能如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.yml     <span class="hljs-comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span><br>├── package.json<br>├── scaffolds       <span class="hljs-comment"># 模版文件夹</span><br>├── <span class="hljs-built_in">source</span>          <span class="hljs-comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br>|   ├── _drafts     <span class="hljs-comment"># 草稿文件</span><br>|   └── _posts      <span class="hljs-comment"># 文章Markdowm文件 </span><br>└── themes          <span class="hljs-comment"># 主题文件夹</span><br></code></pre></td></tr></table></figure><h3 id="3-导入-fluid-主题"><a href="#3-导入-fluid-主题" class="headerlink" title="3. 导入 fluid 主题"></a>3. 导入 fluid 主题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，该文件为主题配置文件，具体配置参见 <a href="https://hexo.fluid-dev.com/docs/guide/">Configuration</a>。我的个人配置仅作参考：<a href="https://paste.ubuntu.com/p/bmNjKsWZW9/" target="_blank">ZewanBlog_config.fluid.yml</a></p><p>如下修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>        <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>     <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>运行 <code>hexo s</code> 命令，在本地浏览 <a href="http://localhost:4000/">http://localhost:4000</a> 可以预览效果。</p><h3 id="4-新建-GitHub-仓库"><a href="#4-新建-GitHub-仓库" class="headerlink" title="4. 新建 GitHub 仓库"></a>4. 新建 GitHub 仓库</h3><p>注意仓库名必须是 用户名.github.io</p><h3 id="5-部署到-GitHub"><a href="#5-部署到-GitHub" class="headerlink" title="5. 部署到 GitHub"></a>5. 部署到 GitHub</h3><p>在 _config.yml 配置文件中修改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span><br>    <span class="hljs-attr">github:</span> <span class="hljs-string">https://github.com/ZewanHuang/ZewanHuang.github.io</span>  <span class="hljs-comment"># 修改自己的仓库</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>安装部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank">hexo-deployer-git</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>最后执行命令部署上传，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean      <span class="hljs-comment"># 清除缓存文件和已生成的静态文件</span><br>hexo g -d       <span class="hljs-comment"># 部署上传</span><br></code></pre></td></tr></table></figure><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="创建关于页面"><a href="#创建关于页面" class="headerlink" title="创建关于页面"></a>创建关于页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about     <span class="hljs-comment"># 创建关于页面</span><br></code></pre></td></tr></table></figure><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;article-title&#x27;</span>    <span class="hljs-comment"># 新建页面</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean                  <span class="hljs-comment"># 清除缓存</span><br>hexo g -d                   <span class="hljs-comment"># 部署上传</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
